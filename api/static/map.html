<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Карта фотографий - Smart Photo Search</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Toolbar */
        .toolbar {
            padding: 12px 20px;
            background: #16213e;
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-label {
            color: #888;
            font-size: 13px;
        }

        input[type="date"] {
            padding: 8px 12px;
            font-size: 14px;
            border: none;
            border-radius: 6px;
            background: #0f3460;
            color: #fff;
            outline: none;
        }

        input[type="date"]:focus {
            box-shadow: 0 0 0 2px #e94560;
        }

        .btn {
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #e94560;
            color: white;
        }

        .btn-primary:hover {
            background: #ff6b6b;
        }

        .btn-secondary {
            background: #0f3460;
            color: #aaa;
        }

        .btn-secondary:hover {
            background: #1a4a7a;
            color: #fff;
        }

        .nav-link {
            color: #888;
            text-decoration: none;
            font-size: 20px;
            padding: 6px 10px;
            border-radius: 6px;
            transition: all 0.2s;
            line-height: 1;
        }

        .nav-link:hover {
            color: #fff;
            background: #0f3460;
        }

        /* Format filters */
        .filters {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }

        .filter-label {
            color: #888;
            font-size: 13px;
        }

        .filter-checkbox {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            font-size: 13px;
            color: #aaa;
        }

        .filter-checkbox input {
            accent-color: #e94560;
            width: 15px;
            height: 15px;
            cursor: pointer;
        }

        .filter-checkbox:hover {
            color: #fff;
        }

        /* Stats panel */
        .stats-panel {
            background: #0f3460;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            color: #aaa;
        }

        .stats-panel strong {
            color: #e94560;
        }

        /* Map container */
        .map-wrapper {
            position: relative;
            flex: 1;
            overflow: hidden;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        /* Custom cluster markers */
        .cluster-marker {
            background: #e94560;
            border: 3px solid #fff;
            border-radius: 50%;
            color: #fff;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            cursor: pointer;
            transition: transform 0.2s;
        }

        .cluster-marker:hover {
            transform: scale(1.1);
        }

        .cluster-small {
            width: 36px;
            height: 36px;
            font-size: 12px;
        }

        .cluster-medium {
            width: 46px;
            height: 46px;
            font-size: 14px;
        }

        .cluster-large {
            width: 56px;
            height: 56px;
            font-size: 16px;
        }

        .cluster-huge {
            width: 66px;
            height: 66px;
            font-size: 18px;
            background: #ff6b6b;
        }

        /* Popup styles */
        .leaflet-popup-content-wrapper {
            background: #16213e;
            color: #fff;
            border-radius: 8px;
        }

        .leaflet-popup-content {
            margin: 12px;
        }

        .leaflet-popup-tip {
            background: #16213e;
        }

        .popup-content {
            min-width: 250px;
            max-width: 350px;
        }

        .popup-content h3 {
            margin: 0 0 10px 0;
            color: #e94560;
            font-size: 16px;
        }

        .popup-thumbnails {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
            margin-top: 10px;
        }

        .popup-thumbnail {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            border-radius: 4px;
            background: #0f3460;
        }

        .popup-loading {
            text-align: center;
            padding: 10px;
            color: #aaa;
            font-size: 13px;
        }

        .popup-btn {
            display: inline-block;
            margin-top: 10px;
            padding: 8px 16px;
            background: #e94560;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
        }

        .popup-btn:hover {
            background: #ff6b6b;
        }

        /* Fullscreen button */
        .btn-fullscreen {
            background: #0f3460;
            color: #aaa;
            padding: 10px;
            min-width: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-fullscreen:hover {
            background: #1a4a7a;
            color: #fff;
        }

        .btn-fullscreen svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* Exit fullscreen button (floating) */
        .exit-fullscreen-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 3000;
            background: rgba(22, 33, 62, 0.9);
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            display: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        .exit-fullscreen-btn:hover {
            background: #e94560;
        }

        .exit-fullscreen-btn svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        /* Fullscreen mode (native API) */
        body:fullscreen .toolbar,
        body:-webkit-full-screen .toolbar,
        body:-moz-full-screen .toolbar {
            display: none;
        }

        body:fullscreen .exit-fullscreen-btn,
        body:-webkit-full-screen .exit-fullscreen-btn,
        body:-moz-full-screen .exit-fullscreen-btn {
            display: block;
        }

        body:fullscreen .map-wrapper,
        body:-webkit-full-screen .map-wrapper,
        body:-moz-full-screen .map-wrapper {
            height: 100vh;
        }

        body:fullscreen .person-chips,
        body:-webkit-full-screen .person-chips,
        body:-moz-full-screen .person-chips {
            display: none;
        }

        /* iOS fallback - pseudo fullscreen mode */
        body.ios-fullscreen .toolbar {
            display: none;
        }

        body.ios-fullscreen .exit-fullscreen-btn {
            display: block;
        }

        body.ios-fullscreen .map-wrapper {
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 2500;
        }

        body.ios-fullscreen .person-chips {
            display: none;
        }

        /* Layer control styling */
        .leaflet-control-layers {
            background: rgba(40, 40, 40, 0.95);
            border: 1px solid #555;
            border-radius: 4px;
        }

        .leaflet-control-layers-toggle {
            background-color: rgba(40, 40, 40, 0.95);
            background-size: 20px 20px;
        }

        .leaflet-control-layers-expanded {
            color: #fff;
            background: rgba(40, 40, 40, 0.95);
            padding: 10px;
        }

        .leaflet-control-layers-base label {
            color: #fff;
        }

        .leaflet-control-layers-separator {
            border-top: 1px solid #555;
        }

        /* Person filter chips (floating on map) */
        .person-chips {
            position: absolute;
            top: 10px;
            left: 60px;
            z-index: 1000;
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            max-width: 50%;
        }

        .person-chip {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px 3px 3px;
            background: rgba(22, 33, 62, 0.92);
            border: 1px solid #4ade80;
            border-radius: 20px;
            font-size: 12px;
            color: #eee;
            cursor: default;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        .person-chip-avatar {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: #0f3460;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
        }

        .person-chip-close {
            cursor: pointer;
            color: #888;
            font-size: 14px;
            line-height: 1;
            margin-left: 2px;
            transition: color 0.15s;
        }

        .person-chip-close:hover {
            color: #e94560;
        }

        /* Responsive: iPad / tablet */
        @media (max-width: 1100px) {
            .toolbar {
                padding: 8px 12px;
                gap: 8px;
            }

            .nav-gps { display: none; }
            .filter-label { display: none; }
            .stats-panel { display: none; }

            input[type="date"] {
                width: 130px;
                font-size: 12px;
                padding: 6px 8px;
            }

            .toolbar-label { font-size: 11px; }
            .filters { gap: 6px; }
            .filter-checkbox { font-size: 12px; }
        }

        /* Responsive: phone */
        @media (max-width: 600px) {
            .toolbar {
                padding: 6px 8px;
                gap: 6px;
            }

            .btn-fullscreen {
                background: #e94560;
                color: white;
            }

            .person-chips {
                left: 10px;
                max-width: 70%;
            }

            input[type="date"] {
                width: 110px;
            }
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <a href="/" class="nav-link" title="Поиск">&#128269;</a>
        <a href="/map.html" class="nav-link" style="color:#e94560;" title="Карта">&#128506;</a>
        <a href="/geo_assign.html" class="nav-link nav-gps" title="GPS">&#128205;</a>
        <a href="/admin.html" class="nav-link" title="Админ">&#9881;</a>

        <div class="filters">
            <span class="filter-label">Форматы:</span>
            <label class="filter-checkbox">
                <input type="checkbox" id="filterAll">
                Все
            </label>
            <label class="filter-checkbox">
                <input type="checkbox" class="format-filter" value="jpg,jpeg" checked>
                JPG
            </label>
            <label class="filter-checkbox">
                <input type="checkbox" class="format-filter" value="heic,heif" checked>
                HEIC
            </label>
            <label class="filter-checkbox">
                <input type="checkbox" class="format-filter" value="png">
                PNG
            </label>
            <label class="filter-checkbox">
                <input type="checkbox" class="format-filter" value="nef" checked>
                NEF
            </label>
        </div>

        <div class="toolbar-section">
            <span class="toolbar-label">С:</span>
            <input type="date" id="dateFrom">
        </div>

        <div class="toolbar-section">
            <span class="toolbar-label">По:</span>
            <input type="date" id="dateTo">
        </div>

        <div id="personSelectorContainer"></div>

        <button class="btn btn-fullscreen" onclick="toggleFullscreen()" title="На весь экран">
            <svg viewBox="0 0 24 24">
                <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
            </svg>
        </button>

        <div class="stats-panel" id="statsPanel">
            Загрузка статистики...
        </div>
    </div>

    <div class="map-wrapper">
        <div id="map"></div>

        <!-- Selected person chips floating on map -->
        <div class="person-chips" id="personChips"></div>
    </div>

    <!-- Exit fullscreen button (shown only in fullscreen mode) -->
    <button class="exit-fullscreen-btn" onclick="exitFullscreen()" title="Выйти из полноэкранного режима">
        <svg viewBox="0 0 24 24">
            <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>
        </svg>
    </button>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="/person_selector.js"></script>

    <script>
        // Map state
        let map;
        let clusterLayer;
        let currentClusters = [];
        let dateFrom = null;
        let dateTo = null;
        let selectedFormats = null;  // null = all formats
        let popupTimers = new Map();  // Track hover timers for each marker
        let selectedPersonIds = [];  // Person IDs for filtering
        let personSelector = null;

        // Filter elements (initialized after DOM ready)
        let filterAll;
        let formatFilters;

        // Get allowed formats from checkboxes
        function getAllowedFormats() {
            const formats = [];
            formatFilters.forEach(f => {
                if (f.checked) {
                    formats.push(...f.value.split(','));
                }
            });
            return formats;
        }

        // Update formats state and reload clusters
        function updateFormatsAndReload() {
            const formats = getAllowedFormats();
            const allSelected = [...formatFilters].every(f => f.checked);
            selectedFormats = allSelected ? null : formats;
            loadClusters();
        }

        // Initialize format filters
        function initFilters() {
            filterAll = document.getElementById('filterAll');
            formatFilters = document.querySelectorAll('.format-filter');

            // Set initial state based on checkboxes (PNG is unchecked by default)
            const allChecked = [...formatFilters].every(f => f.checked);
            const noneChecked = [...formatFilters].every(f => !f.checked);
            filterAll.checked = allChecked;
            filterAll.indeterminate = !allChecked && !noneChecked;

            // Initialize selectedFormats based on current checkbox state
            if (!allChecked) {
                selectedFormats = getAllowedFormats();
            }

            // Filter "All" checkbox logic
            filterAll.addEventListener('change', () => {
                formatFilters.forEach(f => f.checked = filterAll.checked);
                updateFormatsAndReload();
            });

            // Individual format checkbox change - instant apply
            formatFilters.forEach(f => {
                f.addEventListener('change', () => {
                    const allChecked = [...formatFilters].every(f => f.checked);
                    const noneChecked = [...formatFilters].every(f => !f.checked);
                    filterAll.checked = allChecked;
                    filterAll.indeterminate = !allChecked && !noneChecked;
                    updateFormatsAndReload();
                });
            });

            // Date filters - instant apply on change
            document.getElementById('dateFrom').addEventListener('change', (e) => {
                dateFrom = e.target.value || null;
                loadClusters();
            });
            document.getElementById('dateTo').addEventListener('change', (e) => {
                dateTo = e.target.value || null;
                loadClusters();
            });
        }

        // Parse URL parameters for initial view
        function parseUrlParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                center_lat: params.get('center_lat') ? parseFloat(params.get('center_lat')) : null,
                center_lon: params.get('center_lon') ? parseFloat(params.get('center_lon')) : null,
                zoom: params.get('zoom') ? parseInt(params.get('zoom')) : null
            };
        }

        // Initialize map
        function initMap() {
            const urlParams = parseUrlParams();
            const initialCenter = (urlParams.center_lat && urlParams.center_lon)
                ? [urlParams.center_lat, urlParams.center_lon]
                : [20, 0];
            const initialZoom = urlParams.zoom || 2;

            map = L.map('map', {
                center: initialCenter,
                zoom: initialZoom,
                minZoom: 2,
                maxZoom: 18
            });

            // Define base layers
            const standardLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19
            });

            const topoLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)',
                maxZoom: 17
            });

            const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
                maxZoom: 18
            });

            const darkLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 20
            });

            // Add default standard layer
            standardLayer.addTo(map);

            // Layer control
            const baseLayers = {
                "Стандартный": standardLayer,
                "Топографический": topoLayer,
                "Спутник": satelliteLayer,
                "Темный": darkLayer
            };

            L.control.layers(baseLayers).addTo(map);

            // Create layer for clusters
            clusterLayer = L.layerGroup().addTo(map);

            // Load clusters on map move
            map.on('moveend', loadClusters);
            map.on('zoomend', loadClusters);

            // Initial load
            loadStats(!urlParams.center_lat); // Don't fit bounds if center was specified
            loadClusters();
        }

        // Load map stats
        async function loadStats(fitBoundsIfAvailable = true) {
            try {
                const response = await fetch('/map/stats');
                const data = await response.json();

                const statsHtml = `
                    <strong>${data.with_gps.toLocaleString()}</strong> фото с GPS
                    (${data.gps_percentage}% из ${data.total_photos.toLocaleString()})
                `;
                document.getElementById('statsPanel').innerHTML = statsHtml;

                // Set default date range if available
                if (data.date_range.min && data.date_range.max) {
                    document.getElementById('dateFrom').min = data.date_range.min.split('T')[0];
                    document.getElementById('dateTo').max = data.date_range.max.split('T')[0];
                }

                // Fit map to data bounds if available and not overridden by URL params
                if (fitBoundsIfAvailable && data.geo_bounds.min_lat !== null) {
                    const bounds = [
                        [data.geo_bounds.min_lat, data.geo_bounds.min_lon],
                        [data.geo_bounds.max_lat, data.geo_bounds.max_lon]
                    ];
                    map.fitBounds(bounds, { padding: [50, 50], maxZoom: 10 });
                }
            } catch (error) {
                console.error('Error loading stats:', error);
                document.getElementById('statsPanel').innerHTML = 'Ошибка загрузки статистики';
            }
        }

        // Load clusters for current viewport
        async function loadClusters() {
            const bounds = map.getBounds();
            const zoom = map.getZoom();

            showLoading(true);

            try {
                const requestBody = {
                    min_lat: bounds.getSouth(),
                    max_lat: bounds.getNorth(),
                    min_lon: bounds.getWest(),
                    max_lon: bounds.getEast(),
                    zoom: zoom,
                    date_from: dateFrom,
                    date_to: dateTo
                };
                if (selectedFormats && selectedFormats.length > 0) {
                    requestBody.formats = selectedFormats;
                }
                if (selectedPersonIds.length > 0) {
                    requestBody.person_ids = selectedPersonIds;
                }

                const response = await fetch('/map/clusters', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    console.error('Clusters API error:', response.status, await response.text());
                    displayClusters([]);
                    return;
                }

                const data = await response.json();
                displayClusters(data.clusters || []);

            } catch (error) {
                console.error('Error loading clusters:', error);
            } finally {
                showLoading(false);
            }
        }

        // Display clusters on map
        function displayClusters(clusters) {
            clusterLayer.clearLayers();
            currentClusters = clusters;

            clusters.forEach(cluster => {
                const marker = createClusterMarker(cluster);
                clusterLayer.addLayer(marker);
            });
        }

        // Create cluster marker
        function createClusterMarker(cluster) {
            // Determine marker size based on count
            let sizeClass = 'cluster-small';
            let size = 36;

            if (cluster.count >= 1000) {
                sizeClass = 'cluster-huge';
                size = 66;
            } else if (cluster.count >= 100) {
                sizeClass = 'cluster-large';
                size = 56;
            } else if (cluster.count >= 10) {
                sizeClass = 'cluster-medium';
                size = 46;
            }

            // Format count
            let countText = cluster.count;
            if (cluster.count >= 1000) {
                countText = Math.round(cluster.count / 1000) + 'k';
            }

            // Create custom icon
            const icon = L.divIcon({
                className: '',
                html: `<div class="cluster-marker ${sizeClass}">${countText}</div>`,
                iconSize: [size, size],
                iconAnchor: [size / 2, size / 2]
            });

            const marker = L.marker([cluster.latitude, cluster.longitude], { icon });

            // Click handler - always open photos
            marker.on('click', () => {
                openClusterPhotos(cluster);
            });

            // Create popup with loading state
            const popupContent = `
                <div class="popup-content">
                    <h3>${cluster.count} фото</h3>
                    <div class="popup-loading">Загрузка превью...</div>
                </div>
            `;
            marker.bindPopup(popupContent, { closeButton: false, maxWidth: 350 });

            // Delayed popup on hover (0.5s delay)
            marker.on('mouseover', function() {
                const markerId = L.stamp(this);
                
                // Cancel any existing timer
                if (popupTimers.has(markerId)) {
                    clearTimeout(popupTimers.get(markerId));
                }
                
                // Set new timer
                const timer = setTimeout(async () => {
                    this.openPopup();
                    // Load thumbnails after popup opens
                    await loadClusterThumbnails(cluster, this);
                    popupTimers.delete(markerId);
                }, 500);
                
                popupTimers.set(markerId, timer);
            });
            
            marker.on('mouseout', function() {
                const markerId = L.stamp(this);
                
                // Cancel timer if exists
                if (popupTimers.has(markerId)) {
                    clearTimeout(popupTimers.get(markerId));
                    popupTimers.delete(markerId);
                }
                
                this.closePopup();
            });

            return marker;
        }

        // Load cluster thumbnails for popup
        async function loadClusterThumbnails(cluster, marker) {
            try {
                const params = new URLSearchParams();
                params.set('min_lat', cluster.min_lat);
                params.set('max_lat', cluster.max_lat);
                params.set('min_lon', cluster.min_lon);
                params.set('max_lon', cluster.max_lon);
                params.set('limit', '10');  // Load only first 10 photos
                params.set('offset', '0');
                
                if (dateFrom) params.set('date_from', dateFrom);
                if (dateTo) params.set('date_to', dateTo);
                if (selectedFormats && selectedFormats.length > 0) {
                    params.set('formats', selectedFormats.join(','));
                }
                if (selectedPersonIds.length > 0) {
                    params.set('person_ids', selectedPersonIds.join(','));
                }

                const response = await fetch(`/map/photos?${params.toString()}`);
                const data = await response.json();
                
                // Build thumbnails HTML
                let thumbnailsHtml = '<div class="popup-thumbnails">';
                data.photos.slice(0, 10).forEach(photo => {
                    thumbnailsHtml += `<img src="/image/${photo.image_id}/thumb?size=200" class="popup-thumbnail" alt="">`;
                });
                thumbnailsHtml += '</div>';
                
                // Update popup content
                const newContent = `
                    <div class="popup-content">
                        <h3>${cluster.count} фото</h3>
                        ${thumbnailsHtml}
                    </div>
                `;
                marker.setPopupContent(newContent);
                
            } catch (error) {
                console.error('Failed to load cluster thumbnails:', error);
                // Show error in popup
                const errorContent = `
                    <div class="popup-content">
                        <h3>${cluster.count} фото</h3>
                        <div class="popup-loading" style="color: #e94560;">Ошибка загрузки</div>
                    </div>
                `;
                marker.setPopupContent(errorContent);
            }
        }

        // Open photos in new tab
        function openClusterPhotos(cluster) {
            // Build URL with geo bounds and date filters
            const params = new URLSearchParams();
            params.set('min_lat', cluster.min_lat);
            params.set('max_lat', cluster.max_lat);
            params.set('min_lon', cluster.min_lon);
            params.set('max_lon', cluster.max_lon);

            if (dateFrom) params.set('date_from', dateFrom);
            if (dateTo) params.set('date_to', dateTo);
            if (selectedFormats && selectedFormats.length > 0) {
                params.set('formats', selectedFormats.join(','));
            }
            if (selectedPersonIds.length > 0) {
                params.set('person_ids', selectedPersonIds.join(','));
            }

            // Open results page in new tab
            window.open(`/results.html?${params.toString()}`, '_blank');
        }


        // Show/hide loading (disabled - was distracting during map scroll)
        function showLoading(show) {
            // Do nothing - loading popup disabled
        }

        // Detect iOS (iPhone, iPad, iPod)
        function isIOS() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                   (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        }

        // Check if native fullscreen API is available
        function hasFullscreenAPI() {
            return document.documentElement.requestFullscreen ||
                   document.documentElement.webkitRequestFullscreen ||
                   document.documentElement.mozRequestFullScreen;
        }

        // Toggle fullscreen mode
        function toggleFullscreen() {
            // iOS doesn't support Fullscreen API - use CSS fallback
            if (isIOS() || !hasFullscreenAPI()) {
                document.body.classList.toggle('ios-fullscreen');
                setTimeout(() => map && map.invalidateSize(), 100);
                return;
            }

            if (!document.fullscreenElement &&
                !document.webkitFullscreenElement &&
                !document.mozFullScreenElement) {
                // Enter fullscreen
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen();
                }
            } else {
                exitFullscreen();
            }
        }

        // Exit fullscreen mode
        function exitFullscreen() {
            // iOS fallback
            if (document.body.classList.contains('ios-fullscreen')) {
                document.body.classList.remove('ios-fullscreen');
                setTimeout(() => map && map.invalidateSize(), 100);
                return;
            }

            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            }
        }

        // Handle fullscreen change - invalidate map size
        document.addEventListener('fullscreenchange', () => {
            setTimeout(() => map && map.invalidateSize(), 100);
        });
        document.addEventListener('webkitfullscreenchange', () => {
            setTimeout(() => map && map.invalidateSize(), 100);
        });

        // Render person chips on map
        function renderPersonChips(persons) {
            const chipsContainer = document.getElementById('personChips');
            if (persons.length === 0) {
                chipsContainer.innerHTML = '';
                return;
            }
            chipsContainer.innerHTML = persons.map(p => {
                const thumbStyle = p.cover_face_id
                    ? `background-image:url(/faces/${p.cover_face_id}/thumb);background-size:cover;background-position:center;`
                    : '';
                return `
                    <div class="person-chip">
                        <div class="person-chip-avatar" style="${thumbStyle}"></div>
                        <span>${p.name}</span>
                        <span class="person-chip-close" data-pid="${p.person_id}">&times;</span>
                    </div>
                `;
            }).join('');

            // Close button handlers
            chipsContainer.querySelectorAll('.person-chip-close').forEach(btn => {
                btn.addEventListener('click', () => {
                    const pid = parseInt(btn.dataset.pid);
                    personSelector.removePerson(pid);
                });
            });
        }

        // Handle person selection change
        function onPersonSelectionChange(persons) {
            selectedPersonIds = persons.map(p => p.person_id);
            renderPersonChips(persons);
            loadClusters();
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            initFilters();
            initMap();

            // Init person selector
            personSelector = new PersonSelector({
                container: document.getElementById('personSelectorContainer'),
                onSelectionChange: onPersonSelectionChange
            });
        });
    </script>
</body>
</html>
