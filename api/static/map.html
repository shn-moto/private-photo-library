<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Карта фотографий - Smart Photo Search</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Toolbar */
        .toolbar {
            padding: 12px 20px;
            background: #16213e;
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-label {
            color: #888;
            font-size: 13px;
        }

        input[type="date"] {
            padding: 8px 12px;
            font-size: 14px;
            border: none;
            border-radius: 6px;
            background: #0f3460;
            color: #fff;
            outline: none;
        }

        input[type="date"]:focus {
            box-shadow: 0 0 0 2px #e94560;
        }

        .btn {
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #e94560;
            color: white;
        }

        .btn-primary:hover {
            background: #ff6b6b;
        }

        .btn-secondary {
            background: #0f3460;
            color: #aaa;
        }

        .btn-secondary:hover {
            background: #1a4a7a;
            color: #fff;
        }

        .nav-link {
            color: #888;
            text-decoration: none;
            font-size: 20px;
            padding: 6px 10px;
            border-radius: 6px;
            transition: all 0.2s;
            line-height: 1;
        }

        .nav-link:hover {
            color: #fff;
            background: #0f3460;
        }

        /* Format filters */
        .filters {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }

        .filter-label {
            color: #888;
            font-size: 13px;
        }

        .filter-checkbox {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            font-size: 13px;
            color: #aaa;
        }

        .filter-checkbox input {
            accent-color: #e94560;
            width: 15px;
            height: 15px;
            cursor: pointer;
        }

        .filter-checkbox:hover {
            color: #fff;
        }

        /* Stats panel */
        .stats-panel {
            background: #0f3460;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            color: #aaa;
        }

        .stats-panel strong {
            color: #e94560;
        }

        /* Map container */
        .map-wrapper {
            position: relative;
            flex: 1;
            overflow: hidden;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        /* Custom cluster markers */
        .cluster-marker {
            border: 3px solid #fff;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            cursor: pointer;
            transition: transform 0.2s;
            overflow: hidden;
            position: relative;
        }

        .cluster-marker:hover {
            transform: scale(1.1);
        }

        /* Fallback: no thumbnails */
        .cluster-marker.no-preview {
            background: #e94560;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
        }

        .cluster-small { width: 40px; height: 40px; }
        .cluster-medium { width: 50px; height: 50px; }
        .cluster-large { width: 60px; height: 60px; }
        .cluster-huge { width: 70px; height: 70px; }
        .cluster-marker.no-preview.cluster-small { font-size: 12px; }
        .cluster-marker.no-preview.cluster-medium { font-size: 14px; }
        .cluster-marker.no-preview.cluster-large { font-size: 16px; }
        .cluster-marker.no-preview.cluster-huge { font-size: 18px; }

        /* Single photo filling the cluster circle */
        .cluster-thumb {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        /* Count badge overlay */
        .cluster-count {
            position: absolute;
            bottom: 0;
            right: 0;
            background: rgba(233, 69, 96, 0.85);
            color: #fff;
            font-weight: bold;
            font-size: 10px;
            padding: 1px 5px;
            border-radius: 6px 0 0 0;
            line-height: 1.3;
            pointer-events: none;
        }
        .cluster-huge .cluster-count,
        .cluster-large .cluster-count { font-size: 12px; padding: 2px 6px; }

        /* Popup styles */
        .leaflet-popup-content-wrapper {
            background: #16213e;
            color: #fff;
            border-radius: 8px;
        }

        .leaflet-popup-content {
            margin: 12px;
        }

        .leaflet-popup-tip {
            background: #16213e;
        }

        .popup-content {
            min-width: 250px;
            max-width: 350px;
        }

        .popup-content h3 {
            margin: 0 0 10px 0;
            color: #e94560;
            font-size: 16px;
        }

        .popup-thumbnails {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
            margin-top: 10px;
        }

        .popup-thumbnail {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            border-radius: 4px;
            background: #0f3460;
        }

        .popup-loading {
            text-align: center;
            padding: 10px;
            color: #aaa;
            font-size: 13px;
        }

        .popup-btn {
            display: inline-block;
            margin-top: 10px;
            padding: 8px 16px;
            background: #e94560;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
        }

        .popup-btn:hover {
            background: #ff6b6b;
        }

        /* Fullscreen button */
        .btn-fullscreen {
            background: #0f3460;
            color: #aaa;
            padding: 10px;
            min-width: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-fullscreen:hover {
            background: #1a4a7a;
            color: #fff;
        }

        .btn-fullscreen svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* Exit fullscreen button (floating) */
        .exit-fullscreen-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 3000;
            background: rgba(22, 33, 62, 0.9);
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            display: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        .exit-fullscreen-btn:hover {
            background: #e94560;
        }

        .exit-fullscreen-btn svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        /* Fullscreen mode (native API) */
        body:fullscreen .toolbar,
        body:-webkit-full-screen .toolbar,
        body:-moz-full-screen .toolbar {
            display: none;
        }

        body:fullscreen .exit-fullscreen-btn,
        body:-webkit-full-screen .exit-fullscreen-btn,
        body:-moz-full-screen .exit-fullscreen-btn {
            display: block;
        }

        body:fullscreen .map-wrapper,
        body:-webkit-full-screen .map-wrapper,
        body:-moz-full-screen .map-wrapper {
            height: 100vh;
        }

        body:fullscreen .person-chips,
        body:-webkit-full-screen .person-chips,
        body:-moz-full-screen .person-chips {
            display: none;
        }

        /* iOS fallback - pseudo fullscreen mode */
        body.ios-fullscreen .toolbar {
            display: none;
        }

        body.ios-fullscreen .exit-fullscreen-btn {
            display: block;
        }

        body.ios-fullscreen .map-wrapper {
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 2500;
        }

        body.ios-fullscreen .person-chips {
            display: none;
        }

        /* Layer control styling */
        .leaflet-control-layers {
            background: rgba(40, 40, 40, 0.95);
            border: 1px solid #555;
            border-radius: 4px;
        }

        .leaflet-control-layers-toggle {
            background-color: rgba(40, 40, 40, 0.95);
            background-size: 20px 20px;
        }

        .leaflet-control-layers-expanded {
            color: #fff;
            background: rgba(40, 40, 40, 0.95);
            padding: 10px;
        }

        .leaflet-control-layers-base label {
            color: #fff;
        }

        .leaflet-control-layers-separator {
            border-top: 1px solid #555;
        }

        /* Person filter chips (floating on map) */
        .person-chips {
            position: absolute;
            top: 10px;
            left: 60px;
            z-index: 1000;
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            max-width: 50%;
        }

        .person-chip {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px 3px 3px;
            background: rgba(22, 33, 62, 0.92);
            border: 1px solid #4ade80;
            border-radius: 20px;
            font-size: 12px;
            color: #eee;
            cursor: default;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        .person-chip-avatar {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: #0f3460;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
        }

        .person-chip-close {
            cursor: pointer;
            color: #888;
            font-size: 14px;
            line-height: 1;
            margin-left: 2px;
            transition: color 0.15s;
        }

        .person-chip-close:hover {
            color: #e94560;
        }

        /* Responsive: iPad / tablet */
        @media (max-width: 1100px) {
            .toolbar {
                padding: 8px 12px;
                gap: 8px;
            }

            .nav-gps { display: none; }
            .filter-label { display: none; }
            .stats-panel { display: none; }

            input[type="date"] {
                width: 130px;
                font-size: 12px;
                padding: 6px 8px;
            }

            .toolbar-label { font-size: 11px; }
            .filters { gap: 6px; }
            .filter-checkbox { font-size: 12px; }
        }

        /* Responsive: phone */
        @media (max-width: 600px) {
            .toolbar {
                padding: 6px 8px;
                gap: 6px;
            }

            .btn-fullscreen {
                background: #e94560;
                color: white;
            }

            .person-chips {
                left: 10px;
                max-width: 70%;
            }

            input[type="date"] {
                width: 110px;
            }
        }

        /* ===== MOBILE UI — Drawer System ===== */

        .mobile-only { display: none !important; }

        .drawer-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1999;
            -webkit-tap-highlight-color: transparent;
        }
        .drawer-overlay.active { display: block; }

        .drawer {
            position: fixed;
            top: 0; bottom: 0;
            width: 85vw;
            max-width: 300px;
            background: rgba(22, 33, 62, 0.82);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            z-index: 2000;
            padding: 20px;
            overflow-y: auto;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            -webkit-overflow-scrolling: touch;
        }
        .drawer-left {
            left: 0;
            transform: translateX(-100%);
            border-right: 1px solid rgba(255,255,255,0.1);
        }
        .drawer-right {
            right: 0;
            transform: translateX(100%);
            border-left: 1px solid rgba(255,255,255,0.1);
        }
        .drawer.open { transform: translateX(0); }

        .drawer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .drawer-title { color: #e94560; font-size: 16px; font-weight: 600; }
        .drawer-close {
            width: 32px; height: 32px;
            border: none; border-radius: 50%;
            background: rgba(255,255,255,0.1);
            color: #aaa; font-size: 18px;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        .drawer-close:hover { background: #e94560; color: #fff; }

        .drawer-section { margin-bottom: 20px; }
        .drawer-section-label {
            color: #888; font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }
        .drawer .filter-item {
            display: flex; align-items: center; gap: 10px;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 14px; color: #ccc; cursor: pointer;
        }
        .drawer .filter-item input[type="checkbox"] {
            width: 18px; height: 18px;
            accent-color: #e94560; cursor: pointer;
        }
        .drawer .setting-row {
            display: flex; align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .drawer .setting-row label { color: #aaa; font-size: 14px; min-width: 30px; }
        .drawer .setting-row input[type="date"] {
            flex: 1; padding: 8px 10px; font-size: 14px;
            border: none; border-radius: 6px;
            background: #0f3460; color: #fff; outline: none;
            width: auto;
        }
        .drawer .person-selector-wrapper { padding: 10px 0; }

        /* ===== Mobile ≤1024px ===== */
        @media (max-width: 1024px) {
            .mobile-only { display: flex !important; }

            .nav-link[href^="/admin.html"],
            .nav-link[href^="/geo_assign.html"] {
                display: none !important;
            }

            /* Hide desktop toolbar elements — moved to drawers */
            .filters { display: none !important; }
            .toolbar > .toolbar-section { display: none !important; }
            .stats-panel { display: none !important; }
            #personSelectorContainer { display: none !important; }
            #settingsMenuBtn { display: none !important; }

            .toolbar {
                flex-direction: row !important;
                flex-wrap: nowrap !important;
                align-items: center !important;
                padding: 8px 12px;
                gap: 6px;
            }

            .nav-link { padding: 6px 8px; font-size: 18px; }

            .mobile-menu-btn {
                width: 36px; height: 36px;
                border: none; border-radius: 8px;
                background: #0f3460; color: #fff;
                font-size: 18px; cursor: pointer;
                display: flex; align-items: center; justify-content: center;
                flex-shrink: 0;
                transition: background 0.2s;
                -webkit-tap-highlight-color: transparent;
            }
            .mobile-menu-btn:hover,
            .mobile-menu-btn:active { background: #1a4a7a; }

            .mobile-spacer { flex: 1; }
        }

        @media (max-width: 480px) {
            .toolbar { padding: 6px 8px; gap: 4px; }
            .nav-link { padding: 4px 6px; font-size: 16px; }
            .mobile-menu-btn { width: 32px; height: 32px; font-size: 16px; }
        }

        /* AI Assistant */
        .btn-ai {
            display: flex; align-items: center; gap: 4px;
            padding: 6px 12px; background: rgba(74,222,128,0.15);
            border: 1px solid rgba(74,222,128,0.4); border-radius: 6px;
            color: #4ade80; font-size: 13px; font-weight: 600;
            cursor: pointer; transition: all 0.2s; white-space: nowrap;
        }
        .btn-ai:hover { background: rgba(74,222,128,0.25); border-color: #4ade80; }
        .btn-ai svg { width: 18px; height: 18px; fill: currentColor; }

        .ai-overlay {
            display: none; position: fixed; inset: 0;
            background: rgba(0,0,0,0.85); z-index: 6000;
            align-items: center; justify-content: center;
        }
        .ai-overlay.active { display: flex; }

        .ai-modal {
            background: #16213e; border-radius: 12px;
            width: 90%; max-width: 560px; height: 75vh; max-height: 650px;
            display: flex; flex-direction: column;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
        }
        .ai-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 14px 18px; border-bottom: 1px solid rgba(255,255,255,0.1);
            flex-shrink: 0;
        }
        .ai-title { font-size: 16px; font-weight: 600; color: #eee; display: flex; align-items: center; gap: 8px; }
        .ai-title svg { width: 22px; height: 22px; fill: #4ade80; }
        .ai-close {
            background: none; border: none; color: #888; font-size: 26px;
            cursor: pointer; padding: 0 4px; line-height: 1;
        }
        .ai-close:hover { color: #fff; }

        .ai-chat {
            flex: 1; overflow-y: auto; padding: 16px;
            display: flex; flex-direction: column; gap: 10px;
        }
        .ai-msg { display: flex; gap: 10px; animation: aiFadeIn 0.3s ease; }
        .ai-msg.user { flex-direction: row-reverse; }
        @keyframes aiFadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }

        .ai-avatar {
            width: 32px; height: 32px; border-radius: 50%; flex-shrink: 0;
            display: flex; align-items: center; justify-content: center; font-size: 16px;
        }
        .ai-msg.user .ai-avatar { background: #e94560; }
        .ai-msg.assistant .ai-avatar { background: #4ade80; color: #000; }

        .ai-bubble {
            max-width: 75%; padding: 10px 14px; border-radius: 12px;
            line-height: 1.5; font-size: 13px;
        }
        .ai-msg.user .ai-bubble { background: #0f3460; color: #fff; border-bottom-right-radius: 4px; }
        .ai-msg.assistant .ai-bubble {
            background: rgba(74,222,128,0.12); color: #eee;
            border: 1px solid rgba(74,222,128,0.25); border-bottom-left-radius: 4px;
        }

        .ai-dots { display: flex; gap: 4px; padding: 8px 0; }
        .ai-dot {
            width: 7px; height: 7px; border-radius: 50%; background: #4ade80;
            animation: aiPulse 1.4s infinite;
        }
        .ai-dot:nth-child(2) { animation-delay: 0.2s; }
        .ai-dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes aiPulse { 0%,80%,100% { opacity: 0.3; transform: scale(0.8); } 40% { opacity: 1; transform: scale(1.2); } }

        .ai-examples {
            padding: 6px 18px 10px; border-top: 1px solid rgba(255,255,255,0.08); flex-shrink: 0;
        }
        .ai-examples-label { font-size: 11px; color: #666; margin-bottom: 6px; }
        .ai-chips { display: flex; flex-wrap: wrap; gap: 5px; }
        .ai-chip {
            padding: 5px 10px; background: rgba(74,222,128,0.08);
            border: 1px solid rgba(74,222,128,0.25); border-radius: 14px;
            font-size: 11px; color: #4ade80; cursor: pointer; transition: all 0.2s;
        }
        .ai-chip:hover { background: rgba(74,222,128,0.18); border-color: #4ade80; }

        .ai-input-area {
            padding: 12px 18px; border-top: 1px solid rgba(255,255,255,0.1);
            display: flex; gap: 8px; flex-shrink: 0;
        }
        .ai-input {
            flex: 1; padding: 10px 14px; background: #0f3460;
            border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;
            color: #eee; font-size: 13px; outline: none; resize: none;
            max-height: 80px; font-family: inherit;
        }
        .ai-input:focus { border-color: #4ade80; }
        .ai-send {
            padding: 10px 18px; background: #4ade80; border: none; border-radius: 8px;
            color: #000; font-size: 13px; font-weight: 600; cursor: pointer;
            transition: background 0.2s; flex-shrink: 0;
        }
        .ai-send:hover { background: #3bc76d; }
        .ai-send:disabled { opacity: 0.5; cursor: not-allowed; }

        @media (max-width: 600px) {
            .ai-modal { width: 100%; height: 100vh; max-height: 100vh; border-radius: 0; }
            .ai-bubble { max-width: 85%; }
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <button class="mobile-menu-btn mobile-only" id="filterMenuBtn" title="Фильтры" onclick="openFilterDrawer()">&#9776;</button>

        <a href="/" class="nav-link" title="Поиск">&#128269;</a>
        <a href="/map.html" class="nav-link" style="color:#e94560;" title="Карта">&#128506;</a>
        <a href="/geo_assign.html" class="nav-link nav-gps" title="GPS">&#128205;</a>
        <a href="/albums.html" class="nav-link" title="Альбомы">&#128218;</a>
        <a href="/duplicates.html" class="nav-link" title="Дубликаты">&#9851;</a>
        <a href="/admin.html" class="nav-link" title="Админ">&#9881;</a>

        <div class="mobile-spacer mobile-only"></div>

        <div class="filters">
            <span class="filter-label">Форматы:</span>
            <label class="filter-checkbox">
                <input type="checkbox" id="filterAll">
                Все
            </label>
            <label class="filter-checkbox">
                <input type="checkbox" class="format-filter" value="jpg,jpeg" checked>
                JPG
            </label>
            <label class="filter-checkbox">
                <input type="checkbox" class="format-filter" value="heic,heif" checked>
                HEIC
            </label>
            <label class="filter-checkbox">
                <input type="checkbox" class="format-filter" value="png">
                PNG
            </label>
            <label class="filter-checkbox">
                <input type="checkbox" class="format-filter" value="nef" checked>
                NEF
            </label>
        </div>

        <div class="toolbar-section">
            <span class="toolbar-label">С:</span>
            <input type="date" id="dateFrom">
        </div>

        <div class="toolbar-section">
            <span class="toolbar-label">По:</span>
            <input type="date" id="dateTo">
        </div>

        <div id="personSelectorContainer"></div>

        <button class="btn-ai" onclick="openAIAssistant()" title="AI Помощник">
            <svg viewBox="0 0 24 24"><path d="M12 2L9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.64-7.03L22 9.24l-7.19-.61z"/></svg>
            AI
        </button>

        <button class="btn btn-fullscreen" onclick="toggleFullscreen()" title="На весь экран">
            <svg viewBox="0 0 24 24">
                <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
            </svg>
        </button>

        <div class="stats-panel" id="statsPanel">
            Загрузка статистики...
        </div>

        <button class="mobile-menu-btn mobile-only" id="settingsMenuBtn" title="Настройки" onclick="openSettingsDrawer()">&#9881;</button>
    </div>

    <!-- Drawer Overlay -->
    <div class="drawer-overlay" id="drawerOverlay"></div>

    <!-- Left Drawer: Filters -->
    <div class="drawer drawer-left" id="filterDrawer">
        <div class="drawer-header">
            <span class="drawer-title">Фильтры</span>
            <button class="drawer-close" onclick="closeDrawers()">&times;</button>
        </div>
        <div class="drawer-section">
            <div class="drawer-section-label">Форматы</div>
            <label class="filter-item"><input type="checkbox" id="mobileFilterAll"> Все форматы</label>
            <label class="filter-item"><input type="checkbox" class="mobile-format-filter" value="jpg,jpeg" checked> JPG</label>
            <label class="filter-item"><input type="checkbox" class="mobile-format-filter" value="heic,heif" checked> HEIC</label>
            <label class="filter-item"><input type="checkbox" class="mobile-format-filter" value="png"> PNG</label>
            <label class="filter-item"><input type="checkbox" class="mobile-format-filter" value="nef" checked> NEF</label>
        </div>
        <div class="drawer-section">
            <div class="drawer-section-label">Фильтр по персоне</div>
            <div class="person-selector-wrapper" id="mobilePersonSelectorContainer"></div>
        </div>
        <div class="drawer-section">
            <div class="drawer-section-label">Период</div>
            <div class="setting-row">
                <label>С:</label>
                <input type="date" id="mobileDateFrom">
            </div>
            <div class="setting-row">
                <label>По:</label>
                <input type="date" id="mobileDateTo">
            </div>
        </div>
        <div class="drawer-section">
            <div style="color:#888;font-size:13px;" id="mobileStatsPanel"></div>
        </div>
    </div>

    <!-- Right Drawer: Settings (desktop only) -->
    <div class="drawer drawer-right" id="settingsDrawer">
        <div class="drawer-header">
            <span class="drawer-title">Настройки</span>
            <button class="drawer-close" onclick="closeDrawers()">&times;</button>
        </div>
    </div>

    <div class="map-wrapper">
        <div id="map"></div>

        <!-- Selected person chips floating on map -->
        <div class="person-chips" id="personChips"></div>
    </div>

    <!-- Exit fullscreen button (shown only in fullscreen mode) -->
    <button class="exit-fullscreen-btn" onclick="exitFullscreen()" title="Выйти из полноэкранного режима">
        <svg viewBox="0 0 24 24">
            <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>
        </svg>
    </button>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="/person_selector.js"></script>

    <script>
        // Map state
        let map;
        let clusterLayer;
        let currentClusters = [];
        let dateFrom = null;
        let dateTo = null;
        let selectedFormats = null;  // null = all formats
        let popupTimers = new Map();  // Track hover timers for each marker
        let selectedPersonIds = [];  // Person IDs for filtering
        let personMode = 'or';  // 'or' = any person, 'and' = all persons on same photo
        let personSelector = null;
        let _suppressMoveEnd = false; // suppress moveend/zoomend during programmatic map moves

        // Filter elements (initialized after DOM ready)
        let filterAll;
        let formatFilters;

        // Get allowed formats from checkboxes
        function getAllowedFormats() {
            const formats = [];
            formatFilters.forEach(f => {
                if (f.checked) {
                    formats.push(...f.value.split(','));
                }
            });
            return formats;
        }

        // Update formats state and reload clusters
        function updateFormatsAndReload() {
            const formats = getAllowedFormats();
            const allSelected = [...formatFilters].every(f => f.checked);
            selectedFormats = allSelected ? null : formats;
            loadClusters();
        }

        // Initialize format filters
        function initFilters() {
            filterAll = document.getElementById('filterAll');
            formatFilters = document.querySelectorAll('.format-filter');

            // Set initial state based on checkboxes (PNG is unchecked by default)
            const allChecked = [...formatFilters].every(f => f.checked);
            const noneChecked = [...formatFilters].every(f => !f.checked);
            filterAll.checked = allChecked;
            filterAll.indeterminate = !allChecked && !noneChecked;

            // Initialize selectedFormats based on current checkbox state
            if (!allChecked) {
                selectedFormats = getAllowedFormats();
            }

            // Filter "All" checkbox logic
            filterAll.addEventListener('change', () => {
                formatFilters.forEach(f => f.checked = filterAll.checked);
                updateFormatsAndReload();
            });

            // Individual format checkbox change - instant apply
            formatFilters.forEach(f => {
                f.addEventListener('change', () => {
                    const allChecked = [...formatFilters].every(f => f.checked);
                    const noneChecked = [...formatFilters].every(f => !f.checked);
                    filterAll.checked = allChecked;
                    filterAll.indeterminate = !allChecked && !noneChecked;
                    updateFormatsAndReload();
                });
            });

            // Date filters - instant apply on change
            document.getElementById('dateFrom').addEventListener('change', (e) => {
                dateFrom = e.target.value || null;
                loadClusters();
            });
            document.getElementById('dateTo').addEventListener('change', (e) => {
                dateTo = e.target.value || null;
                loadClusters();
            });
        }

        // Parse URL parameters for initial view
        function parseUrlParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                center_lat: params.get('center_lat') ? parseFloat(params.get('center_lat')) : null,
                center_lon: params.get('center_lon') ? parseFloat(params.get('center_lon')) : null,
                zoom: params.get('zoom') ? parseInt(params.get('zoom')) : null
            };
        }

        // Initialize map
        function initMap() {
            const urlParams = parseUrlParams();
            const initialCenter = (urlParams.center_lat && urlParams.center_lon)
                ? [urlParams.center_lat, urlParams.center_lon]
                : [20, 0];
            const initialZoom = urlParams.zoom || 2;

            map = L.map('map', {
                center: initialCenter,
                zoom: initialZoom,
                minZoom: 2,
                maxZoom: 18
            });

            // Define base layers
            const standardLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19
            });

            const topoLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)',
                maxZoom: 17
            });

            const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
                maxZoom: 18
            });

            const darkLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 20
            });

            // Add default standard layer
            standardLayer.addTo(map);

            // Layer control
            const baseLayers = {
                "Стандартный": standardLayer,
                "Топографический": topoLayer,
                "Спутник": satelliteLayer,
                "Темный": darkLayer
            };

            L.control.layers(baseLayers).addTo(map);

            // Create layer for clusters
            clusterLayer = L.layerGroup().addTo(map);

            // Load clusters on map move (with suppression flag for programmatic moves)
            map.on('moveend', () => { if (!_suppressMoveEnd) loadClusters(); });
            map.on('zoomend', () => { if (!_suppressMoveEnd) loadClusters(); });

            // Initial load
            loadStats(!urlParams.center_lat); // Don't fit bounds if center was specified
            loadClusters();
        }

        // Load map stats
        async function loadStats(fitBoundsIfAvailable = true) {
            try {
                const response = await fetch('/map/stats');
                const data = await response.json();

                const statsHtml = `
                    <strong>${data.with_gps.toLocaleString()}</strong> фото с GPS
                    (${data.gps_percentage}% из ${data.total_photos.toLocaleString()})
                `;
                document.getElementById('statsPanel').innerHTML = statsHtml;

                // Set default date range if available
                if (data.date_range.min && data.date_range.max) {
                    document.getElementById('dateFrom').min = data.date_range.min.split('T')[0];
                    document.getElementById('dateTo').max = data.date_range.max.split('T')[0];
                }

                // Fit map to data bounds if available and not overridden by URL params
                if (fitBoundsIfAvailable && data.geo_bounds.min_lat !== null) {
                    const bounds = [
                        [data.geo_bounds.min_lat, data.geo_bounds.min_lon],
                        [data.geo_bounds.max_lat, data.geo_bounds.max_lon]
                    ];
                    map.fitBounds(bounds, { padding: [50, 50], maxZoom: 10 });
                }
            } catch (error) {
                console.error('Error loading stats:', error);
                document.getElementById('statsPanel').innerHTML = 'Ошибка загрузки статистики';
            }
        }

        // Load clusters for viewport. Pass globalSearch=true for AI search (world bounds).
        async function loadClusters(globalSearch, boundsOverride) {
            const bounds = map.getBounds();
            const zoom = map.getZoom();

            showLoading(true);

            try {
                let reqBounds;
                if (boundsOverride) {
                    reqBounds = boundsOverride;
                } else if (globalSearch) {
                    reqBounds = { min_lat: -85, max_lat: 85, min_lon: -180, max_lon: 180 };
                } else {
                    reqBounds = { min_lat: bounds.getSouth(), max_lat: bounds.getNorth(), min_lon: bounds.getWest(), max_lon: bounds.getEast() };
                }
                const requestBody = {
                    min_lat: reqBounds.min_lat,
                    max_lat: reqBounds.max_lat,
                    min_lon: reqBounds.min_lon,
                    max_lon: reqBounds.max_lon,
                    zoom: (globalSearch || boundsOverride) ? 12 : zoom,
                    date_from: dateFrom,
                    date_to: dateTo
                };
                if (selectedFormats && selectedFormats.length > 0) {
                    requestBody.formats = selectedFormats;
                }
                if (selectedPersonIds.length > 0) {
                    requestBody.person_ids = selectedPersonIds;
                    requestBody.person_mode = personMode;
                }
                if (activeClipImageIds) {
                    // Cached IDs from previous search — fast, no re-search
                    requestBody.clip_image_ids = activeClipImageIds;
                } else if (activeClipSearch) {
                    // First search — send query, will get IDs back
                    requestBody.clip_query = activeClipSearch;
                    requestBody.original_query = activeOriginalQuery;
                }

                const response = await fetch('/map/clusters', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    console.error('Clusters API error:', response.status, await response.text());
                    displayClusters([]);
                    return;
                }

                const data = await response.json();

                // Cache CLIP image IDs from first search
                if (data.clip_image_ids && !activeClipImageIds) {
                    activeClipImageIds = data.clip_image_ids;
                    console.log(`Cached ${activeClipImageIds.length} CLIP image IDs`);
                }

                displayClusters(data.clusters || []);

            } catch (error) {
                console.error('Error loading clusters:', error);
            } finally {
                showLoading(false);
            }
        }

        // Display clusters on map
        function displayClusters(clusters) {
            clusterLayer.clearLayers();
            currentClusters = clusters;

            clusters.forEach(cluster => {
                const marker = createClusterMarker(cluster);
                clusterLayer.addLayer(marker);
            });
        }

        // Create cluster marker
        function createClusterMarker(cluster) {
            // Determine marker size based on count
            let sizeClass = 'cluster-small';
            let size = 40;

            if (cluster.count >= 1000) {
                sizeClass = 'cluster-huge';
                size = 70;
            } else if (cluster.count >= 100) {
                sizeClass = 'cluster-large';
                size = 60;
            } else if (cluster.count >= 10) {
                sizeClass = 'cluster-medium';
                size = 50;
            }

            // Format count
            let countText = cluster.count;
            if (cluster.count >= 1000) {
                countText = Math.round(cluster.count / 1000) + 'k';
            }

            // Build cluster icon HTML with photo preview
            const previewId = (cluster.preview_ids || [])[0];
            let innerHtml;
            if (previewId) {
                innerHtml = `<img class="cluster-thumb" src="/image/${previewId}/thumb?size=200"><span class="cluster-count">${countText}</span>`;
            } else {
                innerHtml = countText;
            }

            const icon = L.divIcon({
                className: '',
                html: `<div class="cluster-marker ${sizeClass} ${previewId ? '' : 'no-preview'}">${innerHtml}</div>`,
                iconSize: [size, size],
                iconAnchor: [size / 2, size / 2]
            });

            const marker = L.marker([cluster.latitude, cluster.longitude], { icon });

            // Click handler - always open photos
            marker.on('click', () => {
                openClusterPhotos(cluster);
            });

            // Create popup with loading state
            const popupContent = `
                <div class="popup-content">
                    <h3>${cluster.count} фото</h3>
                    <div class="popup-loading">Загрузка превью...</div>
                </div>
            `;
            marker.bindPopup(popupContent, { closeButton: false, maxWidth: 350 });

            // Delayed popup on hover (0.5s delay)
            marker.on('mouseover', function() {
                const markerId = L.stamp(this);
                
                // Cancel any existing timer
                if (popupTimers.has(markerId)) {
                    clearTimeout(popupTimers.get(markerId));
                }
                
                // Set new timer
                const timer = setTimeout(async () => {
                    this.openPopup();
                    // Load thumbnails after popup opens
                    await loadClusterThumbnails(cluster, this);
                    popupTimers.delete(markerId);
                }, 500);
                
                popupTimers.set(markerId, timer);
            });
            
            marker.on('mouseout', function() {
                const markerId = L.stamp(this);
                
                // Cancel timer if exists
                if (popupTimers.has(markerId)) {
                    clearTimeout(popupTimers.get(markerId));
                    popupTimers.delete(markerId);
                }
                
                this.closePopup();
            });

            return marker;
        }

        // Load cluster thumbnails for popup
        async function loadClusterThumbnails(cluster, marker) {
            try {
                const params = new URLSearchParams();
                params.set('min_lat', cluster.min_lat);
                params.set('max_lat', cluster.max_lat);
                params.set('min_lon', cluster.min_lon);
                params.set('max_lon', cluster.max_lon);
                params.set('limit', '10');  // Load only first 10 photos
                params.set('offset', '0');
                
                if (dateFrom) params.set('date_from', dateFrom);
                if (dateTo) params.set('date_to', dateTo);
                if (selectedFormats && selectedFormats.length > 0) {
                    params.set('formats', selectedFormats.join(','));
                }
                if (selectedPersonIds.length > 0) {
                    params.set('person_ids', selectedPersonIds.join(','));
                    params.set('person_mode', personMode);
                }
                if (activeClipImageIds) {
                    params.set('clip_image_ids', activeClipImageIds.join(','));
                } else if (activeClipSearch) {
                    params.set('clip_query', activeClipSearch);
                }

                const response = await fetch(`/map/photos?${params.toString()}`);
                const data = await response.json();
                
                // Build thumbnails HTML
                let thumbnailsHtml = '<div class="popup-thumbnails">';
                data.photos.slice(0, 10).forEach(photo => {
                    thumbnailsHtml += `<img src="/image/${photo.image_id}/thumb?size=200" class="popup-thumbnail" alt="">`;
                });
                thumbnailsHtml += '</div>';
                
                // Update popup content
                const newContent = `
                    <div class="popup-content">
                        <h3>${cluster.count} фото</h3>
                        ${thumbnailsHtml}
                    </div>
                `;
                marker.setPopupContent(newContent);
                
            } catch (error) {
                console.error('Failed to load cluster thumbnails:', error);
                // Show error in popup
                const errorContent = `
                    <div class="popup-content">
                        <h3>${cluster.count} фото</h3>
                        <div class="popup-loading" style="color: #e94560;">Ошибка загрузки</div>
                    </div>
                `;
                marker.setPopupContent(errorContent);
            }
        }

        // Open photos in new tab
        function openClusterPhotos(cluster) {
            // Build URL with geo bounds and date filters
            const params = new URLSearchParams();
            params.set('min_lat', cluster.min_lat);
            params.set('max_lat', cluster.max_lat);
            params.set('min_lon', cluster.min_lon);
            params.set('max_lon', cluster.max_lon);

            if (dateFrom) params.set('date_from', dateFrom);
            if (dateTo) params.set('date_to', dateTo);
            if (selectedFormats && selectedFormats.length > 0) {
                params.set('formats', selectedFormats.join(','));
            }
            if (selectedPersonIds.length > 0) {
                params.set('person_ids', selectedPersonIds.join(','));
                params.set('person_mode', personMode);
            }
            if (activeClipImageIds) {
                // Pass cached IDs to results page (no re-search needed)
                params.set('clip_image_ids', activeClipImageIds.join(','));
                if (activeOriginalQuery) params.set('original_query', activeOriginalQuery);
            } else if (activeClipSearch) {
                params.set('clip_query', activeClipSearch);
                if (activeOriginalQuery) params.set('original_query', activeOriginalQuery);
            }

            // Open results page in new tab
            window.open(`/results.html?${params.toString()}`, '_blank');
        }


        // Show/hide loading (disabled - was distracting during map scroll)
        function showLoading(show) {
            // Do nothing - loading popup disabled
        }

        // Detect iOS (iPhone, iPad, iPod)
        function isIOS() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                   (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        }

        // Check if native fullscreen API is available
        function hasFullscreenAPI() {
            return document.documentElement.requestFullscreen ||
                   document.documentElement.webkitRequestFullscreen ||
                   document.documentElement.mozRequestFullScreen;
        }

        // Toggle fullscreen mode
        function toggleFullscreen() {
            // iOS doesn't support Fullscreen API - use CSS fallback
            if (isIOS() || !hasFullscreenAPI()) {
                document.body.classList.toggle('ios-fullscreen');
                setTimeout(() => map && map.invalidateSize(), 100);
                return;
            }

            if (!document.fullscreenElement &&
                !document.webkitFullscreenElement &&
                !document.mozFullScreenElement) {
                // Enter fullscreen
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen();
                }
            } else {
                exitFullscreen();
            }
        }

        // Exit fullscreen mode
        function exitFullscreen() {
            // iOS fallback
            if (document.body.classList.contains('ios-fullscreen')) {
                document.body.classList.remove('ios-fullscreen');
                setTimeout(() => map && map.invalidateSize(), 100);
                return;
            }

            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            }
        }

        // Handle fullscreen change - invalidate map size
        document.addEventListener('fullscreenchange', () => {
            setTimeout(() => map && map.invalidateSize(), 100);
        });
        document.addEventListener('webkitfullscreenchange', () => {
            setTimeout(() => map && map.invalidateSize(), 100);
        });

        // Render person chips on map
        function renderPersonChips(persons) {
            const chipsContainer = document.getElementById('personChips');
            if (persons.length === 0) {
                chipsContainer.innerHTML = '';
                return;
            }
            chipsContainer.innerHTML = persons.map(p => {
                const thumbStyle = p.cover_face_id
                    ? `background-image:url(/faces/${p.cover_face_id}/thumb);background-size:cover;background-position:center;`
                    : '';
                return `
                    <div class="person-chip">
                        <div class="person-chip-avatar" style="${thumbStyle}"></div>
                        <span>${p.name}</span>
                        <span class="person-chip-close" data-pid="${p.person_id}">&times;</span>
                    </div>
                `;
            }).join('');

            // Close button handlers
            chipsContainer.querySelectorAll('.person-chip-close').forEach(btn => {
                btn.addEventListener('click', () => {
                    const pid = parseInt(btn.dataset.pid);
                    personSelector.removePerson(pid);
                });
            });
        }

        // Handle person selection change
        function onPersonSelectionChange(persons) {
            selectedPersonIds = persons.map(p => p.person_id);
            personMode = 'or';  // Manual selection uses OR logic
            renderPersonChips(persons);
            loadClusters();
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            initFilters();
            initMap();

            // Timestamp на все nav-ссылки — обход кэша браузера (Telegram browser кэширует HTML)
            const _ts = Date.now().toString(36);
            document.querySelectorAll('a.nav-link[href]').forEach(function(a) {
                var h = a.getAttribute('href');
                if (h && h.startsWith('/')) a.setAttribute('href', h + '?_=' + _ts);
            });
            // Synchronous local/tunnel check — hide admin/GPS nav links on non-local access
            if (!/^(localhost|127\.0\.0\.1|0\.0\.0\.0)$/.test(window.location.hostname)) {
                const s = document.createElement('style');
                s.textContent = '.nav-link[href^="/admin.html"],.nav-link[href^="/geo_assign.html"],.nav-link[href^="/duplicates.html"]{display:none !important}';
                document.head.appendChild(s);
            }

            // Init person selector
            personSelector = new PersonSelector({
                container: document.getElementById('personSelectorContainer'),
                onSelectionChange: onPersonSelectionChange
            });

            // Init mobile person selector
            if (document.getElementById('mobilePersonSelectorContainer')) {
                const mobilePersonSelector = new PersonSelector({
                    container: document.getElementById('mobilePersonSelectorContainer'),
                    onSelectionChange: (persons) => {
                        selectedPersonIds = persons.map(p => p.person_id);
                        renderPersonChips(persons);
                        loadClusters();
                    }
                });
            }
        });

        // ==================== Mobile UI ====================

        const drawerOverlay = document.getElementById('drawerOverlay');
        const filterDrawer = document.getElementById('filterDrawer');
        const settingsDrawer = document.getElementById('settingsDrawer');

        const mobileFilterAll = document.getElementById('mobileFilterAll');
        const mobileFormatFilters = document.querySelectorAll('.mobile-format-filter');

        function syncFiltersToDesktop() {
            const desktopFilterAll = document.getElementById('filterAll');
            const desktopFilters = document.querySelectorAll('.format-filter');
            if (desktopFilterAll) desktopFilterAll.checked = mobileFilterAll.checked;
            mobileFormatFilters.forEach((mf, i) => {
                if (desktopFilters[i]) desktopFilters[i].checked = mf.checked;
            });
        }

        function syncFiltersToMobile() {
            const desktopFilterAll = document.getElementById('filterAll');
            const desktopFilters = document.querySelectorAll('.format-filter');
            if (desktopFilterAll && mobileFilterAll) mobileFilterAll.checked = desktopFilterAll.checked;
            mobileFormatFilters.forEach((mf, i) => {
                if (desktopFilters[i]) mf.checked = desktopFilters[i].checked;
            });
        }

        function syncToMobileDrawers() {
            syncFiltersToMobile();
            const dateFrom = document.getElementById('dateFrom');
            const dateTo = document.getElementById('dateTo');
            const mobileDF = document.getElementById('mobileDateFrom');
            const mobileDT = document.getElementById('mobileDateTo');
            if (dateFrom && mobileDF) mobileDF.value = dateFrom.value;
            if (dateTo && mobileDT) mobileDT.value = dateTo.value;
            const statsPanel = document.getElementById('statsPanel');
            const mobileStatsPanel = document.getElementById('mobileStatsPanel');
            if (statsPanel && mobileStatsPanel) mobileStatsPanel.innerHTML = statsPanel.innerHTML;
        }

        function syncMobileToDesktop() {
            syncFiltersToDesktop();
            const dateFrom = document.getElementById('dateFrom');
            const dateTo = document.getElementById('dateTo');
            const mobileDF = document.getElementById('mobileDateFrom');
            const mobileDT = document.getElementById('mobileDateTo');
            if (dateFrom && mobileDF) dateFrom.value = mobileDF.value;
            if (dateTo && mobileDT) dateTo.value = mobileDT.value;
        }

        function openFilterDrawer() {
            syncToMobileDrawers();
            filterDrawer.classList.add('open');
            drawerOverlay.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function openSettingsDrawer() {
            syncToMobileDrawers();
            settingsDrawer.classList.add('open');
            drawerOverlay.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeDrawers() {
            const wasFilterOpen = filterDrawer.classList.contains('open');
            const wasSettingsOpen = settingsDrawer.classList.contains('open');
            filterDrawer.classList.remove('open');
            settingsDrawer.classList.remove('open');
            drawerOverlay.classList.remove('active');
            document.body.style.overflow = '';
            if (wasFilterOpen || wasSettingsOpen) {
                syncMobileToDesktop();
                // Update JS variables from synced DOM values
                dateFrom = document.getElementById('dateFrom').value || null;
                dateTo = document.getElementById('dateTo').value || null;
                const formats = getAllowedFormats();
                const allSelected = [...formatFilters].every(f => f.checked);
                selectedFormats = allSelected ? null : formats;
                loadClusters();
            }
        }

        drawerOverlay?.addEventListener('click', closeDrawers);

        // Mobile filter "All" checkbox
        mobileFilterAll?.addEventListener('change', () => {
            mobileFormatFilters.forEach(f => f.checked = mobileFilterAll.checked);
        });
        mobileFormatFilters.forEach(f => {
            f.addEventListener('change', () => {
                const allChecked = [...mobileFormatFilters].every(f => f.checked);
                const noneChecked = [...mobileFormatFilters].every(f => !f.checked);
                mobileFilterAll.checked = allChecked;
                mobileFilterAll.indeterminate = !allChecked && !noneChecked;
            });
        });

        // Observe stats changes
        const statsPanelEl = document.getElementById('statsPanel');
        const mobileStatsPanelEl = document.getElementById('mobileStatsPanel');
        if (statsPanelEl && mobileStatsPanelEl) {
            const statsObserver = new MutationObserver(() => {
                mobileStatsPanelEl.innerHTML = statsPanelEl.innerHTML;
            });
            statsObserver.observe(statsPanelEl, { childList: true, characterData: true, subtree: true });
        }

        // Escape closes drawers + AI modal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const aiOverlay = document.getElementById('aiOverlay');
                if (aiOverlay && aiOverlay.classList.contains('active')) {
                    closeAIAssistant();
                    e.stopImmediatePropagation();
                    return;
                }
                if (filterDrawer?.classList.contains('open') || settingsDrawer?.classList.contains('open')) {
                    closeDrawers();
                    e.stopImmediatePropagation();
                }
            }
        }, true);

        // ==================== AI Assistant ====================
        let aiHistory = [];
        let aiProcessing = false;

        function openAIAssistant() {
            document.getElementById('aiOverlay').classList.add('active');
            const inp = document.getElementById('aiInput');
            inp && inp.focus();
            if (aiHistory.length === 0) {
                addAIMsg('assistant', 'Привет! Опишите что ищете, например «покажи Сашу в Камбодже» или «фото за лето 2024».');
            }
        }

        function closeAIAssistant() {
            document.getElementById('aiOverlay').classList.remove('active');
        }

        function addAIMsg(role, text) {
            const chat = document.getElementById('aiChat');
            const div = document.createElement('div');
            div.className = 'ai-msg ' + role;
            const av = document.createElement('div');
            av.className = 'ai-avatar';
            av.textContent = role === 'user' ? '\uD83D\uDC64' : '\uD83E\uDD16';
            const bubble = document.createElement('div');
            bubble.className = 'ai-bubble';
            bubble.textContent = text;
            div.appendChild(av);
            div.appendChild(bubble);
            chat.appendChild(div);
            chat.scrollTop = chat.scrollHeight;
        }

        function showAIDots() {
            const chat = document.getElementById('aiChat');
            const div = document.createElement('div');
            div.className = 'ai-msg assistant';
            div.id = 'aiLoading';
            const av = document.createElement('div');
            av.className = 'ai-avatar';
            av.textContent = '\uD83E\uDD16';
            const dots = document.createElement('div');
            dots.className = 'ai-dots';
            dots.innerHTML = '<div class="ai-dot"></div><div class="ai-dot"></div><div class="ai-dot"></div>';
            div.appendChild(av);
            div.appendChild(dots);
            chat.appendChild(div);
            chat.scrollTop = chat.scrollHeight;
        }

        function hideAIDots() {
            const el = document.getElementById('aiLoading');
            if (el) el.remove();
        }

        async function sendAIMessage() {
            const inp = document.getElementById('aiInput');
            const btn = document.getElementById('aiSend');
            const msg = inp.value.trim();
            if (!msg || aiProcessing) return;

            addAIMsg('user', msg);
            inp.value = '';
            aiProcessing = true;
            btn.disabled = true;
            inp.disabled = true;
            showAIDots();

            try {
                const bounds = map.getBounds();
                const currentState = {
                    min_lat: bounds.getSouth(),
                    max_lat: bounds.getNorth(),
                    min_lon: bounds.getWest(),
                    max_lon: bounds.getEast(),
                    zoom: map.getZoom(),
                    date_from: dateFrom,
                    date_to: dateTo,
                    formats: selectedFormats,
                    person_ids: selectedPersonIds
                };

                const resp = await fetch('/ai/assistant', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        message: msg,
                        conversation_history: aiHistory,
                        current_state: currentState
                    })
                });

                hideAIDots();

                if (!resp.ok) {
                    const err = await resp.json().catch(() => ({}));
                    throw new Error(err.detail || `HTTP ${resp.status}`);
                }

                const data = await resp.json();
                addAIMsg('assistant', data.message);
                aiHistory = data.conversation_history || [];
                const applied = await applyAIActions(data.actions);
                if (applied) {
                    setTimeout(() => closeAIAssistant(), 600);
                }

            } catch (err) {
                hideAIDots();
                console.error('AI error:', err);
                addAIMsg('assistant', 'Ошибка: ' + err.message);
            } finally {
                aiProcessing = false;
                btn.disabled = false;
                inp.disabled = false;
                inp.focus();
            }
        }

        async function applyAIActions(actions) {
            if (!actions || !actions.length) return false;
            let reload = false;
            let textSearchQuery = null;
            let textSearchClipPrompt = null;
            let boundsAction = null;

            // === Clear ALL previous filters before applying new AI actions ===
            dateFrom = null; dateTo = null;
            const dfClear = document.getElementById('dateFrom');
            const dtClear = document.getElementById('dateTo');
            if (dfClear) dfClear.value = '';
            if (dtClear) dtClear.value = '';
            document.querySelectorAll('.format-filter').forEach(f => f.checked = true);
            const filterAllClear = document.getElementById('filterAll');
            if (filterAllClear) filterAllClear.checked = true;
            selectedFormats = null;
            if (personSelector) {
                personSelector.selectedPersons = [];
                personSelector.updateTriggerButton();
            }
            selectedPersonIds = [];
            personMode = 'or';
            renderPersonChips([]);
            activeClipSearch = null;
            activeOriginalQuery = null;
            activeClipImageIds = null;
            const badgeClear = document.getElementById('clipSearchBadge');
            if (badgeClear) badgeClear.style.display = 'none';

            // First pass: collect all actions, process non-bounds immediately
            for (const a of actions) {
                switch (a.type) {
                    case 'set_bounds':
                        if (a.min_lat != null && a.max_lat != null && a.min_lon != null && a.max_lon != null) {
                            boundsAction = a;
                            reload = true;
                        }
                        break;
                    case 'set_persons':
                        if (a.person_ids && a.person_ids.length > 0 && personSelector) {
                            const persons = a.person_ids.map(id =>
                                personSelector.allPersons.find(p => p.person_id === id)
                            ).filter(Boolean);
                            personSelector.selectedPersons = persons;
                            personSelector.updateTriggerButton();
                            selectedPersonIds = a.person_ids;
                            personMode = a.mode || (a.person_ids.length > 1 ? 'and' : 'or');
                            renderPersonChips(persons);
                            reload = true;
                        }
                        break;
                    case 'set_date_range':
                        if (a.date_from) {
                            dateFrom = a.date_from;
                            const el = document.getElementById('dateFrom');
                            if (el) el.value = a.date_from;
                        }
                        if (a.date_to) {
                            dateTo = a.date_to;
                            const el = document.getElementById('dateTo');
                            if (el) el.value = a.date_to;
                        }
                        if (a.date_from || a.date_to) reload = true;
                        break;
                    case 'set_formats':
                        if (a.formats && a.formats.length > 0) {
                            const formatFiltersEls = document.querySelectorAll('.format-filter');
                            formatFiltersEls.forEach(f => {
                                const fmts = f.value.split(',');
                                f.checked = fmts.some(fmt => a.formats.includes(fmt));
                            });
                            selectedFormats = a.formats;
                            reload = true;
                        }
                        break;
                    case 'text_search':
                        if (a.query) {
                            textSearchQuery = a.query;
                            textSearchClipPrompt = a.clip_prompt || null;
                        }
                        break;
                    case 'clear_filters':
                        dateFrom = null; dateTo = null;
                        const df = document.getElementById('dateFrom');
                        const dt = document.getElementById('dateTo');
                        if (df) df.value = '';
                        if (dt) dt.value = '';
                        document.querySelectorAll('.format-filter').forEach(f => f.checked = true);
                        const filterAll = document.getElementById('filterAll');
                        if (filterAll) filterAll.checked = true;
                        selectedFormats = null;
                        if (personSelector) {
                            personSelector.selectedPersons = [];
                            personSelector.updateTriggerButton();
                        }
                        selectedPersonIds = [];
                        personMode = 'or';
                        renderPersonChips([]);
                        _clearClipSearch();
                        reload = true;
                        break;
                }
            }

            // Set up CLIP search BEFORE any map move
            if (textSearchQuery) {
                activeClipImageIds = null; // clear cached IDs from previous search
                if (textSearchClipPrompt) {
                    activeClipSearch = textSearchClipPrompt;
                    activeOriginalQuery = textSearchQuery;
                    _showClipSearchBadge(textSearchQuery);
                } else {
                    await _prepareClipSearch(textSearchQuery);
                }
                reload = true;
            }

            // Suppress all moveend handlers during AI action cycle
            _suppressMoveEnd = true;

            if (reload) {
                // Step 1: Search — use AI geo bounds as filter, or global if no bounds
                const searchBounds = boundsAction
                    ? { min_lat: boundsAction.min_lat, max_lat: boundsAction.max_lat,
                        min_lon: boundsAction.min_lon, max_lon: boundsAction.max_lon }
                    : null;
                console.log('[AI] Step 1: search.', searchBounds ? 'geo filter' : 'global',
                    'activeClipSearch=', activeClipSearch, 'persons=', selectedPersonIds);
                await loadClusters(!searchBounds, searchBounds);
                console.log('[AI] Step 1 done. clusters=', currentClusters.length);

                // Step 2: Always zoom to fit the FOUND clusters (not AI geo bounds)
                if (currentClusters && currentClusters.length > 0) {
                    const lats = currentClusters.flatMap(c => [c.min_lat, c.max_lat]);
                    const lons = currentClusters.flatMap(c => [c.min_lon, c.max_lon]);
                    map.fitBounds(
                        [[Math.min(...lats), Math.min(...lons)], [Math.max(...lats), Math.max(...lons)]],
                        { padding: [60, 60], maxZoom: 15 }
                    );
                    await new Promise(r => setTimeout(r, 400));

                    // Step 3: Reload at zoomed level for proper cluster resolution
                    await loadClusters();
                } else {
                    // Nothing found — show empty map
                    console.log('[AI] No clusters found, clearing map');
                    clusterLayer.clearLayers();
                }
            }

            _suppressMoveEnd = false;
            return reload;
        }

        // Active CLIP search: optimized English prompt for API, original for display
        let activeClipSearch = null;   // optimized English CLIP query
        let activeOriginalQuery = null; // original user query (for display)
        let activeClipImageIds = null; // cached image IDs from first CLIP search (reused on scroll/zoom)

        async function _prepareClipSearch(rawQuery) {
            // Optimize prompt for CLIP via Gemini (LLM gets original, outputs English)
            let clipQuery = rawQuery;
            try {
                const resp = await fetch('/ai/clip-prompt', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({query: rawQuery})
                });
                if (resp.ok) {
                    const data = await resp.json();
                    clipQuery = data.clip_prompt || rawQuery;
                    console.log('CLIP prompt:', rawQuery, '→', clipQuery);
                }
            } catch (e) {
                console.warn('CLIP prompt optimization failed, using raw query:', e);
            }
            activeClipSearch = clipQuery;
            activeOriginalQuery = rawQuery;
            _showClipSearchBadge(rawQuery);
        }

        function _showClipSearchBadge(query) {
            let badge = document.getElementById('clipSearchBadge');
            if (!badge) {
                badge = document.createElement('div');
                badge.id = 'clipSearchBadge';
                badge.style.cssText = 'position:absolute;top:10px;left:50%;transform:translateX(-50%);z-index:1500;background:rgba(74,222,128,0.9);color:#000;padding:6px 14px;border-radius:20px;font-size:13px;font-weight:600;display:flex;align-items:center;gap:8px;box-shadow:0 2px 8px rgba(0,0,0,0.3);';
                document.querySelector('.map-wrapper').appendChild(badge);
            }
            badge.innerHTML = `<span>🔍 ${query}</span><button onclick="_clearClipSearch()" style="background:none;border:none;color:#000;font-size:16px;cursor:pointer;padding:0 2px;line-height:1;">✕</button>`;
            badge.style.display = 'flex';
        }

        function _clearClipSearch() {
            activeClipSearch = null;
            activeOriginalQuery = null;
            activeClipImageIds = null;
            const badge = document.getElementById('clipSearchBadge');
            if (badge) badge.style.display = 'none';
            loadClusters();
        }

        function aiExample(text) {
            document.getElementById('aiInput').value = text;
            sendAIMessage();
        }

        // Enter to send in AI input
        document.getElementById('aiInput')?.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendAIMessage(); }
        });

        // Click overlay to close AI
        document.getElementById('aiOverlay')?.addEventListener('click', (e) => {
            if (e.target.id === 'aiOverlay') closeAIAssistant();
        });
    </script>

    <!-- AI Assistant Modal -->
    <div class="ai-overlay" id="aiOverlay">
        <div class="ai-modal">
            <div class="ai-header">
                <span class="ai-title">
                    <svg viewBox="0 0 24 24"><path d="M12 2L9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.64-7.03L22 9.24l-7.19-.61z"/></svg>
                    AI Помощник
                </span>
                <button class="ai-close" onclick="closeAIAssistant()">&times;</button>
            </div>
            <div class="ai-chat" id="aiChat"></div>
            <div class="ai-examples">
                <div class="ai-examples-label">Примеры:</div>
                <div class="ai-chips">
                    <span class="ai-chip" onclick="aiExample(this.textContent)">Покажи Сашу в Камбодже</span>
                    <span class="ai-chip" onclick="aiExample(this.textContent)">Фото за лето 2024</span>
                    <span class="ai-chip" onclick="aiExample(this.textContent)">Только RAW</span>
                    <span class="ai-chip" onclick="aiExample(this.textContent)">Сбросить фильтры</span>
                </div>
            </div>
            <div class="ai-input-area">
                <textarea class="ai-input" id="aiInput" placeholder="Например: найди фото Саши в Камбодже" rows="1"></textarea>
                <button class="ai-send" id="aiSend" onclick="sendAIMessage()">Отправить</button>
            </div>
        </div>
    </div>
</body>
</html>
